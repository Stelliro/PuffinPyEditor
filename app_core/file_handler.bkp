# PuffinPyEditor/app_core/file_handler.py
import os
import sys
import shutil
import subprocess
import re
from typing import Optional, Tuple, Any, Dict
from PyQt6.QtWidgets import QFileDialog, QMessageBox
from PyQt6.QtGui import QGuiApplication, QDesktopServices
from PyQt6.QtCore import QUrl, pyqtSignal, QObject
from .settings_manager import settings_manager
from utils.logger import log


class FileHandler(QObject):
    item_created = pyqtSignal(str, str)
    item_renamed = pyqtSignal(str, str, str)
    item_deleted = pyqtSignal(str, str)
    recent_files_changed = pyqtSignal()

    def __init__(self, parent_window: Optional[Any] = None):
        super().__init__()
        self.parent_window = parent_window
        self._internal_clipboard: Dict[str, Optional[str]] = {
            "operation": None, "path": None
        }

    def new_file(self) -> Dict[str, Optional[str]]:
        """
        Prepares data for creating a new, empty file tab.

        Returns:
            A dictionary with content, filepath, and a default name.
        """
        log.info("FileHandler: new_file action invoked.")
        return {
            "content": "",
            "filepath": None,
            "new_file_default_name": "Untitled"
        }

    def open_file_dialog(self) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """
        Opens a system dialog to select a file for opening.

        Returns:
            A tuple containing (filepath, content, error_message).
            On success, error_message is None. On failure, all are None.
        """
        last_dir = settings_manager.get(
            "last_opened_directory", os.path.expanduser("~")
        )
        filepath, _ = QFileDialog.getOpenFileName(
            self.parent_window, "Open File", last_dir,
            "Python Files (*.py *.pyw);;All Files (*)"
        )
        if not filepath:
            return None, None, None  # User cancelled

        settings_manager.set(
            "last_opened_directory", os.path.dirname(filepath)
        )
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            self._add_to_recent_files(filepath)
            return filepath, content, None
        except (IOError, OSError, UnicodeDecodeError) as e:
            msg = (f"Error opening file '{os.path.basename(filepath)}'."
                   f"\n\nReason: {e}")
            log.error(msg, exc_info=True)
            return None, None, msg

    def save_file_content(
            self, filepath: Optional[str], content: str, save_as: bool = False
    ) -> Optional[str]:
        """
        Saves content to a file. Prompts for a new path if 'save_as' is True
        or if the initial filepath is invalid.

        Args:
            filepath: The current path of the file, if any.
            content: The text content to save.
            save_as: If True, forces a "Save As" dialog.

        Returns:
            The path where the file was saved, or None if cancelled.
        """
        dir_exists = filepath and os.path.exists(os.path.dirname(filepath))
        if save_as or not filepath or not dir_exists:
            last_dir = (os.path.dirname(filepath) if dir_exists else
                        settings_manager.get("last_saved_directory",
                                             os.path.expanduser("~")))
            sugg_name = os.path.basename(filepath) if filepath else "Untitled.py"

            path_from_dialog, _ = QFileDialog.getSaveFileName(
                self.parent_window, "Save File As",
                os.path.join(last_dir, sugg_name),
                "Python Files (*.py *.pyw);;All Files (*)"
            )
            if not path_from_dialog:
                return None  # User cancelled
            filepath = path_from_dialog
            settings_manager.set(
                "last_saved_directory", os.path.dirname(filepath)
            )

        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            self._add_to_recent_files(filepath)
            return filepath
        except (IOError, OSError) as e:
            msg = f"Error saving file '{filepath}': {e}"
            log.error(msg, exc_info=True)
            QMessageBox.critical(self.parent_window, "Error Saving File", msg)
            return None

    def create_file(self, path: str) -> Tuple[bool, Optional[str]]:
        """Creates a new, empty file at the given path."""
        try:
            if os.path.exists(path):
                item_type = "folder" if os.path.isdir(path) else "file"
                return False, f"A {item_type} named '{os.path.basename(path)}' already exists."
            with open(path, 'w', encoding='utf-8'):
                pass  # Create an empty file
            log.info(f"Created file: {path}")
            self.item_created.emit("file", path)
            return True, None
        except OSError as e:
            log.error(f"Failed to create file at {path}: {e}", exc_info=True)
            return False, f"Failed to create file: {e}"

    def create_folder(self, path: str) -> Tuple[bool, Optional[str]]:
        """Creates a new directory at the given path."""
        try:
            if os.path.exists(path):
                item_type = "folder" if os.path.isdir(path) else "file"
                return False, f"A {item_type} named '{os.path.basename(path)}' already exists."
            os.makedirs(path)
            log.info(f"Created folder: {path}")
            self.item_created.emit("folder", path)
            return True, None
        except OSError as e:
            log.error(f"Failed to create folder at {path}: {e}", exc_info=True)
            return False, f"Failed to create folder: {e}"

    def rename_item(self, old_path: str, new_name: str) -> Tuple[bool, Optional[str]]:
        """Renames a file or folder."""
        new_name = new_name.strip()
        if not new_name:
            return False, "Name cannot be empty."

        if re.search(r'[<>:"/\\|?*]', new_name):
            return False, ('Name contains illegal characters '
                           '(e.g., \\ / : * ? " < > |).')

        new_path = os.path.join(os.path.dirname(old_path), new_name)
        if os.path.exists(new_path):
            return False, f"'{new_name}' already exists here."

        item_type = 'folder' if os.path.isdir(old_path) else 'file'

        try:
            os.rename(old_path, new_path)
            log.info(f"Renamed '{old_path}' to '{new_path}'")
            self.item_renamed.emit(item_type, old_path, new_path)
            return True, new_path
        except OSError as e:
            log.error(f"Failed to rename '{old_path}': {e}", exc_info=True)
            return False, f"Failed to rename: {e}"

    def delete_item(self, path: str) -> Tuple[bool, Optional[str]]:
        """Deletes a file or an entire directory tree."""
        is_file = os.path.isfile(path)
        item_type = 'file' if is_file else 'folder'
        try:
            if is_file:
                os.remove(path)
            elif os.path.isdir(path):
                shutil.rmtree(path)
            log.info(f"Deleted item: {path}")
            self.item_deleted.emit(item_type, path)
            return True, None
        except (OSError, shutil.Error) as e:
            log.error(f"Failed to delete '{path}': {e}", exc_info=True)
            return False, f"Failed to delete: {e}"

    def copy_path_to_clipboard(self, path: str):
        """Copies the given path to the system clipboard."""
        try:
            clipboard = QGuiApplication.clipboard()
            clipboard.setText(os.path.normpath(path))
            log.info(f"Copied path to clipboard: {path}")
            if self.parent_window and hasattr(self.parent_window, "statusBar"):
                self.parent_window.statusBar().showMessage(
                    "Path copied to clipboard", 2000
                )
        except Exception as e:
            log.error(f"Could not copy path to clipboard: {e}")

    def reveal_in_explorer(self, path: str):
        """Opens the system file browser to the location of the given path."""
        try:
            path_to_show = os.path.normpath(path)
            if sys.platform == 'win32':
                if os.path.isdir(path_to_show):
                    subprocess.run(['explorer', path_to_show])
                else:
                    subprocess.run(['explorer', '/select,', path_to_show])
            elif sys.platform == 'darwin':  # macOS
                if os.path.isdir(path_to_show):
                    subprocess.run(['open', path_to_show])
                else:
                    subprocess.run(['open', '-R', path_to_show])
            else:  # Linux and other UNIX-like systems
                dir_path = path_to_show if os.path.isdir(path_to_show) else os.path.dirname(path_to_show)
                subprocess.run(['xdg-open', dir_path])
        except Exception as e:
            log.error(f"Could not open file browser for path '{path}': {e}")
            QMessageBox.warning(self.parent_window, "Error",
                                f"Could not open file browser: {e}")

    def open_with_default_app(self, path: str):
        """Opens a file with the system's default application for its type."""
        try:
            QDesktopServices.openUrl(QUrl.fromLocalFile(path))
        except Exception as e:
            log.error(f"Failed to open '{path}' with default app: {e}")
            QMessageBox.warning(self.parent_window, "Error",
                                f"Could not open file with default application: {e}")

    def duplicate_item(self, path: str) -> Tuple[bool, Optional[str]]:
        """Creates a copy of a file or folder in the same directory."""
        dir_name = os.path.dirname(path)
        base_name, ext = os.path.splitext(os.path.basename(path))
        counter = 1
        new_path = os.path.join(dir_name, f"{base_name}_copy{ext}")
        while os.path.exists(new_path):
            counter += 1
            new_path = os.path.join(dir_name, f"{base_name}_copy_{counter}{ext}")
        try:
            item_type = "folder"
            if os.path.isfile(path):
                shutil.copy2(path, new_path)
                item_type = "file"
            elif os.path.isdir(path):
                shutil.copytree(path, new_path)
            
            log.info(f"Duplicated '{path}' to '{new_path}'")
            # MODIFIED: A duplication is a type of creation, so emit the signal.
            self.item_created.emit(item_type, new_path)
            return True, None
        except (OSError, shutil.Error) as e:
            log.error(f"Failed to duplicate '{path}': {e}", exc_info=True)
            return False, f"Failed to duplicate: {e}"

    def cut_item(self, path: str):
        """Marks an item to be moved on the next paste operation."""
        self._internal_clipboard = {"operation": "cut", "path": path}

    def copy_item(self, path: str):
        """Marks an item to be copied on the next paste operation."""
        self._internal_clipboard = {"operation": "copy", "path": path}

    def paste_item(self, dest_dir: str) -> Tuple[bool, Optional[str]]:
        """Pastes a previously cut or copied item into the destination."""
        op = self._internal_clipboard.get("operation")
        src_path = self._internal_clipboard.get("path")
        if not op or not src_path or not os.path.exists(src_path):
            return False, "Nothing to paste."
        if not os.path.isdir(dest_dir):
            return False, "Paste destination must be a folder."

        dest_path = os.path.join(dest_dir, os.path.basename(src_path))
        if os.path.exists(dest_path):
            return False, f"'{os.path.basename(dest_path)}' already exists in the destination."

        try:
            item_type = 'folder' if os.path.isdir(src_path) else 'file'
            if op == "cut":
                old_path = src_path
                shutil.move(src_path, dest_path)
                log.info(f"Moved '{src_path}' to '{dest_path}'")
                self._internal_clipboard = {"operation": None, "path": None}
                # MODIFIED: A 'cut and paste' is a move, which is functionally a rename.
                self.item_renamed.emit(item_type, old_path, dest_path)
            elif op == "copy":
                if os.path.isfile(src_path):
                    shutil.copy2(src_path, dest_path)
                else:
                    shutil.copytree(src_path, dest_path)
                log.info(f"Copied '{src_path}' to '{dest_path}'")
                # MODIFIED: A copy is a creation at a new location.
                self.item_created.emit(item_type, dest_path)
            return True, None
        except (OSError, shutil.Error) as e:
            log.error(f"Paste operation failed: {e}", exc_info=True)
            return False, f"Paste operation failed: {e}"

    def move_item(self, src_path: str, dest_dir: str) -> Tuple[bool, str]:
        """
        Moves a file or folder to a new directory (for drag-and-drop).

        Returns:
            A tuple of (success, new_path_or_error_msg).
        """
        if not os.path.exists(src_path):
            return False, "Source path does not exist."
        if not os.path.isdir(dest_dir):
            return False, "Destination must be a folder."

        base_name = os.path.basename(src_path)
        dest_path = os.path.join(dest_dir, base_name)
        if os.path.normpath(src_path) == os.path.normpath(dest_path):
            return True, dest_path  # Dropped on itself, do nothing.

        if os.path.exists(dest_path):
            return False, f"'{base_name}' already exists in the destination."

        if os.path.isdir(src_path) and os.path.normpath(dest_dir).startswith(os.path.normpath(src_path)):
            return False, "Cannot move a folder into its own subdirectory."

        try:
            old_path = src_path
            item_type = 'folder' if os.path.isdir(old_path) else 'file'
            shutil.move(src_path, dest_path)
            log.info(f"Moved '{src_path}' to '{dest_path}'")
            # MODIFIED: A drag-drop move is a rename.
            self.item_renamed.emit(item_type, old_path, dest_path)
            return True, dest_path
        except (OSError, shutil.Error) as e:
            log.error(f"Move operation failed: {e}", exc_info=True)
            return False, f"Move operation failed: {e}"

    def get_clipboard_status(self) -> Optional[str]:
        return self._internal_clipboard.get("operation")

    def _add_to_recent_files(self, filepath: str):
        """Adds a file path to the top of the recent files list."""
        if not filepath:
            return
        recents = settings_manager.get("recent_files", [])
        if filepath in recents: recents.remove(filepath)
        recents.insert(0, filepath)
        max_files = settings_manager.get("max_recent_files", 10)
        settings_manager.set("recent_files", recents[:max_files])
        self.recent_files_changed.emit()